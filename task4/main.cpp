#include<stdio.h>
#include "main.h"

volatile int a[1<<size][1<<size];
volatile int b[1<<size][1<<size];
volatile int c[1<<size][1<<size];

int R()
{
	for (int x = 0; x < 1<<size; ++x)
	{
		for (int y = 0; y < 1<<size; ++y)
		{
			for (int i = 0; i < 1<<size; ++i)
			{
				c[x][y] += a[x][i] * b[i][y];
			}
		}
	}

	return 0;

}

int T()
{

	// алгоритм, не смотря на замечания, правильный. поясню его
	
	// cou - это количество сколько отрезков длины стороны матрицы T покроют сторону нашей матрицы
	// формула для общего случая, если стороны не кратные. в нашем случае - всегда cou = (1<<size)/(1<<sT). Я не рассматриваю общий случай - темболее сам алгоритм построен для того, чтоб все кратно было. просто захотелось такую формулу =)
	// для 1x1 получается 1<<size - что правильно
	// каой смысл от cou? мы разбиваем нашу матрицу c[1<<size][1<<size] на квадратики со сторонами 1<<sT. и первые два вложенных цикла бегут по этим квадратам
	int cou = ((1<<size) - 1)/(1<<sT)+1;
	
	for (int x = 0; x < cou; ++x)
        {
                for (int y = 0; y < cou; ++y)
                {
			// вот мы выбрали один из квадратов размерами с T. теперь мы разбиваем на отрезки прямую 0..1<<size-1.
			for(int i1=0; i1<cou; ++i1)
			{
				// следующие 2 вложенных цикла пробегают по всем элементам квадратика размерами T из матрицы c[1<<size][1<<size]
				for(int i=0; i< 1<<sT; ++i)
				{
					for(int j=0; j< 1<<sT; ++j)
                        		{
						int x1 = x * (1<<sT) + i;
						int y1 = y * (1<<sT) + j;
						
						// А вот теперь для каждого элемента мы прибавляем значения из отрезка на который мы били прямую
						// (ну чтоб не менять страницы, а использовать их для всех элементов из квадратика Т нашей матрицы c[1<<size][1<<size])
						for (int i2 = 0; i2 < 1<<sT; ++i2)
                        			{
							// i1*i2 = cou * 1<<sT = ( (1<<size)/(1<<sT) )* 1<<sT = (1<<size)
                                			c[x1][y1] += a[x1][i1*(1<<sT)+i2] * b[i1*(1<<sT)+i2][y1];
                       				}
                        		} 
				}
			}
                }
        }

	// как-то так. извините, за корявый русский - лично могу подробней объяснить алгоритм и его корректность
	// просто мне показалось, что чем реже мы будем сдвигать окна тем лучше будет. именно для этого такое странное разбиение.


	return 0;
}

int main(int argc, char *argv[])
{
	if(argc == 2)
	{
		R();
	}
	else
	{
		T();
	}
	return 0;
}
